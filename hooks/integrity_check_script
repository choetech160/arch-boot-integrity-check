#!/bin/bash

# Define color codes
# RED='\033[38;2;255;0;0m'      # Pure red
# GREEN='\033[38;2;0;255;0m'    # Pure green
YELLOW='\033[38;2;255;255;0m' # Yellow
NC='\033[0m'                  # No Color
GREEN='\e[32m'
RED='\e[31m'

BOOT_PARTITION="/dev/nvme0n1p2"
MOUNT_POINT="/boot"
INTEGRITY_DIR="/etc/boot_integrity"
TOKEN_FILE="$INTEGRITY_DIR/boot_token.enc"
CHALLENGE_FILE="$INTEGRITY_DIR/challenge"
SALT_FILE="$INTEGRITY_DIR/salt.txt"
HASH_FILE="$INTEGRITY_DIR/boot_hash"
TMP_HASH_FILE="/tmp/check_boot"

echo -e "${YELLOW}[+] Starting boot integrity check...${NC}"

if [ ! -f "$CHALLENGE_FILE" ] || [ ! -f "$TOKEN_FILE" ] || [ ! -f "$SALT_FILE" ]; then
  echo -e "[${RED}FAIL${NC}] Challenge, token or salt file not found. Integrity check failed.${NC}"
  exit 1
fi
challenge=$(cat "$CHALLENGE_FILE")
salt=$(cat "$SALT_FILE")
iv_and_token=$(cat "$TOKEN_FILE")
iv="${iv_and_token%%:*}"
encrypted_token="${iv_and_token#*:}"

echo -e "${YELLOW}+-----------------------------------------------+\e[0m"
echo -e "${YELLOW}| Please insert your YubiKey and press ${NC}<Enter>${YELLOW}, |\n|                     or                        |\n| type ${NC}pass${YELLOW} to skip YubiKey verification.       |${NC}"
echo -e "${YELLOW}+-----------------------------------------------+\e[0m"
read -t 30 user_input
if [ "$user_input" = "pass" ] || [ -z "$user_input" ]; then
  echo -e "[${YELLOW}SKIPPPING${NC}] YubiKey verification skipped. ${NC}"
  exit 1
fi

response=$(timeout 15 ykchalresp -2 -x "$challenge")
if [ $? -eq 124 ]; then
  echo -e "[${RED}FAIL${NC}] YubiKey timed out. Integrity check failed.${NC}"
  exit 1
elif [ -z "$response" ]; then
  echo -e "[${RED}FAIL${NC}] No response from YubiKey. Integrity check failed.${NC}"
  exit 1
fi

# Derive the key using PBKDF2
key=$(echo -n "${response}${salt}" | openssl dgst -sha256 -binary | xxd -p -c 64)
# Decript the boot token
boot_token=$(echo "$encrypted_token" | openssl enc -aes-256-cbc -d -base64 -K "$key" -iv "$iv")
if [ $? -ne 0 ]; then
  echo -e "[${RED}FAIL${NC}] Failed to decrypt boot token. Integrity check failed ${NC}"
  exit 1
fi

mkdir -p $MOUNT_POINT
mount $BOOT_PARTITION $MOUNT_POINT

while IFS= read -r -d '' file; do
  sha256sum "$file" >>$TMP_HASH_FILE
done < <(find $MOUNT_POINT -type f ! -name "*.img" ! -path "*/efi/*" -print0)
echo "$(dd if=$MOUNT_POINT/initramfs-linux-fallback.img bs=1M count=1 2>/dev/null | sha256sum | cut -d' ' -f1)  $MOUNT_POINT/initramfs-linux-fallback.img" >>$TMP_HASH_FILE 2>/dev/null #| tee -a $TMP_HASH_FILE
echo "$(dd if=$MOUNT_POINT/initramfs-linux.img bs=1M count=1 2>/dev/null | sha256sum | cut -d' ' -f1)  $MOUNT_POINT/initramfs-linux.img" >>$TMP_HASH_FILE 2>/dev/null                   #| tee -a $TMP_HASH_FILE

# Compare hashes
if diff $TMP_HASH_FILE $HASH_FILE >/dev/null; then
  echo -e "[${GREEN}OK${NC}] Boot file integrity verified\e[0m"

  # Generate a hash of the current boot files and decrypted token
  current_integrity_hash=$(cat "$TMP_HASH_FILE" <(echo -n "$boot_token") | sha256sum)
  stored_integrity_hash=$(cat "$INTEGRITY_DIR/integrity_hash")

  # Compare with stored hashes
  if [ "$current_integrity_hash" = "$stored_integrity_hash" ]; then
    echo -e "[${GREEN}OK${NC}] Boot integrity verified successfully.\e[0m"
  else
    echo -e "[${RED}FAIL${NC}] Boot integrity check failed. System may be compromised\e[0m"
    umount $MOUNT_POINT
    exit 1
  fi
else
  echo -e "[${RED}FAIL${NC}] Boot integrity check failed. Files have been modified.\e[0m"
  echo -e "[${RED}FAIL${NC}] -----------------------------------------\e[0m"
  diff $TMP_HASH_FILE $HASH_FILE
  echo -e "[${RED}FAIL${NC}] -----------------------------------------\e[0m"

  umount $MOUNT_POINT
  exit 1
fi
umount $MOUNT_POINT
echo -e "[${GREEN}OK${NC}] Boot integrity check completed successfully\e[0m"
